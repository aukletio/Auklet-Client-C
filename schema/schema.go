package schema

import (
	"bytes"
	"encoding/json"
	"fmt"
	"time"

	"github.com/satori/go.uuid"

	"github.com/aukletio/Auklet-Client-C/device"
	"github.com/aukletio/Auklet-Client-C/errorlog"
	"github.com/aukletio/Auklet-Client-C/version"
)

type metadata struct {
	Version       string `json:"version"` // user-defined version
	Username      string `json:"device"`
	ClientVersion string `json:"clientVersion"`
	AgentVersion  string `json:"agentVersion"`
	AppID         string `json:"application"`
	CheckSum      string `json:"release"` // SHA512/224 hash of the executable
	MacHash       string `json:"macAddressHash"`
	IP            string `json:"publicIP"`  // current public IP address
	UUID          string `json:"id"`        // identifier for this message
	Time          int64  `json:"timestamp"` // Unix milliseconds
	Error         string `json:"error,omitempty"`
}

func nowMilli() int64 {
	return time.Now().UnixNano() / 1000000 // milliseconds
}

func (c Converter) metadata() metadata {
	return metadata{
		Version:       c.UserVersion,
		Username:      c.Username,
		ClientVersion: version.Version,
		AgentVersion:  c.App.AgentVersion(),
		AppID:         c.AppID,
		CheckSum:      c.App.CheckSum(),
		MacHash:       c.MacHash,
		IP:            device.CurrentIP(),
		UUID:          uuid.NewV4().String(),
		Time:          nowMilli(),
	}
}

// profile represents profile data as expected by broker consumers.
type profile struct {
	metadata
	// Tree represents the profile tree data generated by an agent.
	Tree node `json:"tree"`
}

type node struct {
	Fn       *int64 `json:"functionAddress"`
	Cs       int64  `json:"callSiteAddress"`
	Ncalls   int    `json:"nCalls"`
	Nsamples int    `json:"nSamples"`
	Callees  []node `json:"callees"`
}

func (c Converter) profile(data []byte) profile {
	var p profile
	err := json.Unmarshal(data, &p)
	if err != nil {
		p.Error = err.Error()
		errorlog.Printf("Converter.profile: %v in %q", err, string(data))
	}
	p.metadata = c.metadata()
	return p
}

// errorSig represents the exit of an app in which an agent handled an "error
// signal" and produced a stacktrace.
type errorSig struct {
	metadata
	Status  int            `json:"exitStatus"`
	Signal  string         `json:"signal"`
	Trace   []frame        `json:"stackTrace"`
	Metrics device.Metrics `json:"systemMetrics"`
}

type frame struct {
	Fn *int64 `json:"functionAddress"`
	Cs int64  `json:"callSiteAddress"`
}

func (c Converter) errorSig(data []byte) errorSig {
	var e errorSig
	err := json.Unmarshal(data, &e)
	if err != nil {
		e.Error = err.Error()
		errorlog.Printf("Converter.errorSig: %v in %q", err, string(data))
	}
	e.metadata = c.metadata()
	e.Status = c.App.ExitStatus()
	e.Metrics = c.Monitor.GetMetrics()
	return e
}

// exit represents the exit of an app in which an agent did not handle a
// signal. The app may or may not have been delivered a termination signal of
// some kind, but not one handled by an agent. See man 7 signal for details.
type exit struct {
	metadata
	Status  int            `json:"exitStatus"`
	Signal  string         `json:"signal"`
	Metrics device.Metrics `json:"systemMetrics"`
}

func (c Converter) exit() exit {
	return exit{
		metadata: c.metadata(),
		Status:   c.App.ExitStatus(),
		Signal:   c.App.Signal(),
		Metrics:  c.Monitor.GetMetrics(),
	}
}

type dataPoint struct {
	metadata
	Type    string      `json:"type"`
	Payload interface{} `json:"payload"`
}

func unmarshalStrict(data []byte, v interface{}) error {
	dec := json.NewDecoder(bytes.NewReader(data))
	dec.DisallowUnknownFields()
	if err := dec.Decode(v); err != nil {
		format := "unmarshalStrict: %v in %q"
		return fmt.Errorf(format, err, string(data))
	}
	return nil
}

func (c Converter) dataPoint(data []byte) dataPoint {
	// We unmarshal the type and not the payload,
	// so that we can validate the payload's schema.
	var raw struct {
		Type    string          `json:"type"`
		Payload json.RawMessage `json:"payload"`
	}
	if err := unmarshalStrict(data, &raw); err != nil {
		var d dataPoint
		d.Error = err.Error()
		errorlog.Printf("Converter.dataPoint: %v in %q", err, string(data))
		return d
	}

	switch raw.Type {
	case "", "generic":
		return c.genericDataPoint(raw.Payload)

	case "location":
		return c.locationDataPoint(raw.Payload)

	case "motion":
		return c.motionDataPoint(raw.Payload)
	}

	var d dataPoint
	d.Error = fmt.Sprintf("datapoint: unsupported type %q", raw.Type)
	return d
}

func (c Converter) genericDataPoint(payload []byte) dataPoint {
	generic := dataPoint{
		metadata: c.metadata(),
		Type:     "generic",
	}
	if err := unmarshalStrict(payload, &generic.Payload); err != nil {
		generic.Error = err.Error()
		errorlog.Printf("Converter.genericDataPoint: %v in %q", err, string(payload))
	}
	return generic
}

func (c Converter) locationDataPoint(payload []byte) dataPoint {
	var location struct {
		Speed     float64 `json:"speed"`
		Longitude float64 `json:"longitude"`
		Latitude  float64 `json:"latitude"`
		Altitude  float64 `json:"altitude"`
		Course    float64 `json:"course"`
		Timestamp int     `json:"timestamp"` // unix
		Precision float64 `json:"precision"`
	}
	err := unmarshalStrict(payload, &location)
	d := dataPoint{
		metadata: c.metadata(),
		Type:     "location",
		Payload:  location,
	}
	if err != nil {
		d.Error = err.Error()
		errorlog.Printf("Converter.locationDataPoint: %v in %q", err, string(payload))
	}
	return d
}

func (c Converter) motionDataPoint(payload []byte) dataPoint {
	var motion struct {
		X float64 `json:"x_axis"`
		Y float64 `json:"y_axis"`
		Z float64 `json:"z_axis"`
	}
	err := unmarshalStrict(payload, &motion)
	d := dataPoint{
		metadata: c.metadata(),
		Type:     "motion",
		Payload:  motion,
	}
	if err != nil {
		d.Error = err.Error()
		errorlog.Printf("Converter.motionDataPoint: %v in %q", err, string(payload))
	}
	return d
}
